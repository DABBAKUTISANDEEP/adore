/********************************************************************************
 * Copyright (C) 2017-2020 German Aerospace Center (DLR). 
 * Eclipse ADORe, Automated Driving Open Research https://eclipse.org/adore
 *
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0 
 *
 * Contributors: 
 *   Reza Dariani - initial API and implementation 
 ********************************************************************************/
#include <ros/ros.h>
#include <adore_if_ros/baseapp.h>
#include <adore/fun/afactory.h>
#include <adore/params/afactory.h>
#include <adore/fun/setpointrequest.h>
#include <adore/mad/coordinateconversion.h>
#include <v2xsim/SimMCM.h>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/gregorian/gregorian.hpp>
//#include </home/dari_re/catkin_ws/src/adore/v2x_if_ros/autogenerated/mcm_transaid/mcm_transaid_mcm_transaid/include/mcm_transaid_mcm_transaid.h>


/*
This node reads the set points (planned trajectory) and write it to MCM and broadcast it
*/
namespace adore
{
namespace if_ROS
{
class setpointrequest_to_mcm  : public Baseapp
{
  private: 
      mcm_transaid_mcm_transaid::MCM msg;
      adore::mad::AReader<adore::fun::SetPointRequest>* spr_reader_;  
      adore::mad::AReader<adore::fun::VehicleMotionState9d>* state_reader_;
      adore::params::APVehicle* ap_vehicle_;
      adore::fun::SetPointRequest spr_tmp_;  
      adore::fun::SetPointRequest spr_;
      adore::fun::VehicleMotionState9d state_;
      ros::Publisher setPointRequest_publisher; 
      mcm_transaid_mcm_transaid::TrajectoryPoint tj_point;
      mcm_transaid_mcm_transaid::PlannedTrajectory pl_tj ;      
      double last_t_;  
      int utm_zone_; 
      bool southern_hemisphere;
      double lat, lon;
      int v2xStationID;
  
    public:
      setpointrequest_to_mcm(){ROS_INFO("Constructor");}
      void init(int argc, char **argv, double rate, std::string nodename)
      {
        v2xStationID = 0;
        
        last_t_ = -1.0;
        Baseapp::init(argc, argv, rate, nodename);
        Baseapp::initSim();
        setPointRequest_publisher = getRosNodeHandle()->advertise<mcm_transaid_mcm_transaid::MCM>("v2x/outgoing/MCM",1);
        std::function<void()> run_fcn = (std::bind(&setpointrequest_to_mcm::run_func, this));
        adore::if_ROS::FUN_Factory fun_factory(getRosNodeHandle());
        spr_reader_ = fun_factory.getSetPointRequestReader();
        state_reader_ = fun_factory.getVehicleMotionStateReader();
        Baseapp::addTimerCallback(run_fcn);    
      }
      boost::posix_time::time_duration::tick_type milliseconds_since_epoch()
       {
        using boost::gregorian::date;
        using::boost::posix_time::ptime;
        using::boost::posix_time::microsec_clock;
        static ptime const epoch(date(2004,1,1));
        return (microsec_clock::universal_time() - epoch).total_milliseconds();
        } 
      int getGenerationDeltaTime()
      {
        return milliseconds_since_epoch()%65536;
      }     
      void readSetPointRequest()
      {
        getParam("PARAMS/UTMZone", utm_zone_);
        getParam("PARAMS/SouthHemi",southern_hemisphere);
        getParam("v2xStationID", v2xStationID);        
        msg.header.stationID.value = v2xStationID;
        if( spr_reader_!=0 && spr_reader_->hasData() && state_reader_!=0 && state_reader_->hasData() )
				{
          msg.maneuverCoordination.generationDeltaTime.value = getGenerationDeltaTime();
					state_reader_->getData(state_);
				  const double t = state_.getTime();
          spr_reader_->getData(spr_tmp_);
          if(spr_tmp_.isActive(t))spr_ = spr_tmp_;
          auto trajectory_data = spr_.getTrajectory().getData();
          double X, Y,PSI, T;
          int NumPointsPlannedTrajectory;
          X= trajectory_data(1,0);
          Y= trajectory_data(2,0);          
          PSI= trajectory_data(3,0);
          T = trajectory_data(0,0);
          std::cout<<"\n"<<X<<"\t"<<Y;//<<"\t"<<utm_zone_<<"\t"<<southern_hemisphere;
          PSI = adore::mad::CoordinateConversion::twoPIrange(PSI);
          adore::mad::CoordinateConversion::UTMXYToLatLonDegree(X,Y,utm_zone_,southern_hemisphere,lat,lon);
          msg.maneuverCoordination.mcmParameters.basicContainer.referencePosition.latitude.value = adore::mad::bound(- 900000000,(int)(lat*1.0e7),  900000000);
          msg.maneuverCoordination.mcmParameters.basicContainer.referencePosition.longitude.value = adore::mad::bound(-1800000000,(int)(lon*1.0e7),1800000000);
          msg.maneuverCoordination.mcmParameters.maneuverContainer.vehicleManeuver.heading.headingValue.value = PSI;          
          //std::cout<<msg.maneuverCoordination.mcmParameters.basicContainer.referencePosition.latitude.value;
          int factor = 1;
					static const int MAX_POINTS_IN_MSG = 30; //MCM defined max number
					if(trajectory_data.nc()>=MAX_POINTS_IN_MSG*2)
					{
						factor = std::floor((double)trajectory_data.nc()/(double)MAX_POINTS_IN_MSG);
						NumPointsPlannedTrajectory = MAX_POINTS_IN_MSG;
					}
					else
					{
						NumPointsPlannedTrajectory = std::min((int)MAX_POINTS_IN_MSG,(int)trajectory_data.nc());
					}
          pl_tj.elements.clear() ; 
          pl_tj.count= NumPointsPlannedTrajectory;       
					for( int i=0;i<NumPointsPlannedTrajectory;i++)  //sparsing
					{
            tj_point.deltaTimeMs.value = (unsigned int)((trajectory_data(0,i*factor)-T)*1000.0);
						tj_point.deltaXCm.value = (int)((trajectory_data(1,i*factor)-X)*100.0);
						tj_point.deltaYCm.value = (int)((trajectory_data(2,i*factor)-Y)*100.0);
						tj_point.absSpeed.value = (unsigned int)std::abs(trajectory_data(4,i*factor)*100.0);
            pl_tj.elements.push_back(tj_point);
						T = trajectory_data(0,i*factor);
						X = trajectory_data(1,i*factor);
						Y = trajectory_data(2,i*factor);       
					}           
          msg.maneuverCoordination.mcmParameters.maneuverContainer.vehicleManeuver.plannedTrajectory = pl_tj;       
          std::cout<<"\nMCM is ready to be sent"<<"\t"<< msg.maneuverCoordination.generationDeltaTime.value;
          
        }
      }
    virtual void run_func()
    {
      readSetPointRequest();
      setPointRequest_publisher.publish(msg); 
        
    }

};
} // namespace if_ROS
} // namespace adore




int main(int argc,char **argv)
{

    adore::if_ROS::setpointrequest_to_mcm sprtmcm;
    sprtmcm.init(argc, argv, 20., "setpointrequest_to_mcm_node");
    ROS_INFO("setpointrequest_to_mcm_node namespace is: %s", sprtmcm.getRosNodeHandle()->getNamespace().c_str());
    sprtmcm.run();
    return 0;

}
